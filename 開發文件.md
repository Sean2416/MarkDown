# BaseStore<TModel, TType>

- ###### `~Store` 是作為資料庫處理的類別，為便於維護統一將相關類別命名為`xxxStore`。

- ###### `BaseStore` 為了方便快速開發，因此在框架中提供簡單的Store基底類別處理基本的CRUD。

  - ###### `TModel` : 代表 Entity

  - ###### `TType`: 代表Entity.ID的型態

  - ###### 提供透過Entity.Id進行資料的快速查詢

  - ###### 提供資料的快速 新增、修改、刪除 功能。

  - ###### 只要繼承 `HasCreationTime, IHasModificationTime, ICreationAudited` 等ABP的屬性，則 建立者ID、建立時間、修改者ID、修改時間會自動填入不需要額外撰寫

  - ###### 使用方法如下:

  - ```C#
    public class CustomerStore : BaseStore<Customer, int>
    {
        public CustomerStore(IRepository<Customer> repository, SessionExtension session) :base(repository, session)
        {
        }       
    }
    ```

    ![image-20210314145840088](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210314145840088.png)



# Entity Extension

- ### 由於ABP內建的 建立者、修改者ID 為Long型態，鑑於有些專案需要紀錄字串型別如，建立者的帳號、修改者的帳號...等。因此框架提供額外的延伸功能處理，詳細步驟如下

  1.  繼承對應Entity的 `Extension` ，path: `.Core > Extensions`

     ![image-20210314155045385](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210314155045385.png)

  2.  在`BaseStore` 內部會判斷 **CreateUser**、**LastModificationUser** 決定是否要自動帶入資料。

  3. User的資料會根據 `SessionExtension` 內部的 **UserName**取得，預設是根據登入時的 User.Name從 Claims內部取得。

     1. 若要變更使用者資料的取得，可在Claims中新增對應的屬性，再至`SessionExtension` 中修正

        ![image-20210320104902684](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210320104902684.png)

        

        ![image-20210314155418069](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210314155418069.png)





# 自定義回傳格式 

## 1. Response Structure

- ###### 為便於前端接到Response時處理一致，這邊統一將成功及錯誤的隔式進行定義如下

- ```C#
  /// <summary>
  /// 回覆訊息格式
  /// </summary>
  public class ResponseInfo
  {
      public ResponseInfo(int status, string msg,object data)
      {
          Status = status;
          Msg = msg;
          Data = data;
      }
  
      /// <summary>
      /// 回覆代碼
      /// </summary>
      public int Status { get; set; }
  
      /// <summary>
      /// 回覆訊息
      /// </summary>
      public string Msg { get; set; }
  
      /// <summary>
      /// 回傳資料
      /// </summary>
      public Object Data { get; set; }
  }
  ```

## 2. Error Handle

- ###### 目的:  後端開發api時，不需要再針對每個可能的錯誤進行處理。只需要在需要回傳錯誤資訊時，拋出對應的`Exception` 交給系統統一管理。

- ###### 處理方式: 統一寫入Log內，並根據定義的 `Exception` 型態，找出對應的回傳內容

- ###### `AbpExceptionFilter` - ABP建立用來統一處理錯誤的函式

- ######  為了方便進行維護，建立`ExceptionFilter` 繼承`AbpExceptionFilter`  以方便進行改寫

  - ###### 位置: `ABPFramework.CustomizedResponses > ExceptionFilter `

  - ###### 後續針對錯誤處理，可以統一到`ExceptionFilter` 

- ###### Exception定義

  - ###### UserFriendlyException: 

    - ###### 定義為邏輯性錯誤。ex.Domain Logic判斷、查無資料...

    - ###### 邏輯性錯誤視為Call Api成功，因此 Response StatusCode = 200(可依專案調整)

    - ###### 錯誤內容在 Response.Msg

  - ###### AbpValidationException

    - ###### 前端傳入參數有誤

    - ###### 參數驗證錯誤視為Call Api成功，因此 Response StatusCode = 200(可依專案調整)

    - ###### 錯誤內容在 Response.Data

  - ###### AbpAuthorizationException: 

    - ###### 使用者身分驗證錯誤

    - ###### API進行Auth驗證不會透過Exception處理，因此會直接拋出 `401`錯誤代碼。

  - ###### Others: 

    - ###### 未包含於上述的錯誤格式皆視為系統性錯誤

    - ###### 錯誤內容在 Response.Data

## 3. Respnse

- ###### `AbpResultFilter` - ABP建立用來作為API Response時的統一處理介面

- ######  為了方便進行維護，建立ResultFilter繼承`AbpResultFilter` 以方便進行改寫

  - ###### 針對API Response進行回傳前的資料處理，可以在`OnResultExecuting`進行調整

## 4. 新增步驟

1. ###### 建立繼承`AbpExceptionFilter` / `AbpResultFilter` 並改寫內部方法

2. ###### 至 `xxx.Web＞Startup > Startup.cs` 改寫 ConfigureServices

   - ###### 註冊步驟1 的函示

   - ```c#
     public IServiceProvider ConfigureServices(IServiceCollection services)
     {
     	services.AddMvc(options =>
         {
             options.Filters.AddService(typeof(ExceptionFilter), order: 1);
             options.Filters.AddService(typeof(ResultFilter), order:2);
         });
     }
     ```

3. ###### 至 `xxx.Core＞XXXModule.cs` 改寫 `PreInitialize`

   ```C#
   Configuration.ReplaceService(typeof(IExceptionFilter),
   () =>
   {
       IocManager.Register<IExceptionFilter, ExceptionFilter>(DependencyLifeStyle.Transient);
       IocManager.Register<IResultFilter, ResultFilter>(DependencyLifeStyle.Transient);
   });
   ```

   



# 新增API流程

## 1. Domain Layer

#### 1.1 Entity

- ###### 資料庫實體類別，所有類別需繼承`TEntity` 或其衍生類別，才能使用`IRepository`

- ###### 細節可參考官網文件 > `Domain Layer` > `Entity`

- ```C#
  public class Customer : Entity, IMustHaveTenant
  {
      public string Name { get; set; }
  
      public string Phone { get; set; }
  
      public string Email { get; set; }
  
      public string Address { get; set; }
  
      public DateTime CreationTime { get; set; }
      public int TenantId { get; set; }
  
      public Customer()
      {
      }
  }
  ```

#### 1.2. Repository

- 為了程式的一致性及延展性，Template中提供`BaseStore` 處理基本的CRUD功能。詳情請看 **BaseStore** 章節

- ###### ABP 定義針對資料庫進行C、R、U、D等實際操作行為的基底類別

- 應減少業務邏輯的判斷，單純進行資料庫處理

- ###### 細節可參考官網文件 > `Domain Layer` > `Repositories`

- ###### 為了增加各功能的重複使用性及一致性，統一針對各Entity建立 `xxxStore`來處理資料庫行為。並在其中透過`Repository`進行資料庫處理

- ```C#
  public class CustomerStore : ITransientDependency
  {
      public IRepository<Customer> Repository;
  
      public CustomerStore(IRepository<Customer> repository)
      {
          Repository = repository;
      }
  
      public async Task<List<Customer>> GetCustomerList()
      {
          return await Repository.GetAllListAsync();
      }
      public async Task<Customer> Create(Customer model)
      {
          var customer = await Repository.InsertAsync(model);
          return customer;
      }
  }
  ```

#### 1.3. DomainService	

- 處理業務邏輯之類別，因減少直接針對資料庫進行處理

- ###### 繼承`IDomainService ` 、 `ITransientDependency` 即可在建置階段透過DI的方式自動注入，供其他階層的程式使用

- ###### 依據ABP 命名慣性，統一以 `xxxManager`命名

- ```C#
  public class CustomerManager : IDomainService
  {
      private readonly CustomerStore _store;
  
      public CustomerManager(CustomerStore Store)
      {
          _store = Store;
      }
  
      public async Task<Customer> CreateCustomer(Customer customer)
      {
          if (IsValidEmail(customer.Email))
              throw new UserFriendlyException("Invalid Email Address");
  
          return await _store.Create(customer);
      }
  
      private static bool IsValidEmail(string email)
      {
          if (string.IsNullOrWhiteSpace(email))
              return false;
  
          try
          {
              // Normalize the domain
              email = Regex.Replace(email, @"(@)(.+)$", DomainMapper,
                                      RegexOptions.None, TimeSpan.FromMilliseconds(200));
  
              // Examines the domain part of the email and normalizes it.
              string DomainMapper(Match match)
              {
                  // Use IdnMapping class to convert Unicode domain names.
                  var idn = new IdnMapping();
  
                  // Pull out and process domain name (throws ArgumentException on invalid)
                  var domainName = idn.GetAscii(match.Groups[2].Value);
  
                  return match.Groups[1].Value + domainName;
              }
          }
          catch (RegexMatchTimeoutException e)
          {
              return false;
          }
          catch (ArgumentException e)
          {
              return false;
          }
  
          try
          {
              return Regex.IsMatch(email,
                  @"^(?("")("".+?(?<!\\)""@)|(([0-9a-z]((\.(?!\.))|[-!#\$%&'\*\+/=\?\^`\{\}\|~\w])*)(?<=[0-9a-z])@))" +
                  @"(?(\[)(\[(\d{1,3}\.){3}\d{1,3}\])|(([0-9a-z][-0-9a-z]*[0-9a-z]*\.)+[a-z0-9][\-a-z0-9]{0,22}[a-z0-9]))$",
                  RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(250));
          }
          catch (RegexMatchTimeoutException)
          {
              return false;
          }
      }
  
  }
  ```

#### 1.4 資料結構

- ###### 為了維持統一的架構，各類別依據其`功能` >`Entity` 進行切割

- ###### 下圖為例

  - ###### 首先，將與`使用者管理` 等功能相關的類別統一放置

  - ###### 再依據`Entity`的資料內容區分為`使用者相關`、`腳色相關`...等

![image-20210211185935081](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210211185935081.png)

#### 1.5 流程	

1. ###### 建立 `Entity`

2. ###### 新建 `xxxStore` 處理資料庫CRUD

3. ###### 建立資料庫連線及資料錨點

   - ###### 詳請請參考 `Entity Framework Core`

4. ###### 新增 `xxxManager` 處理業務邏輯 

## 2. Application Layer

#### 2.1 DTO

- ###### 作為 `Application Layer` 跟 `Presentation Layer` 之間傳遞的參數

- ###### 使傳遞參數物件化，讓每一個參數更具意義

- 詳情請參考 `Applciation Layer` > `Data Transfer Objects`

- 透過`AutoMap` 可讓DTO 與 Entity之間進行自動轉換

- ```C#
  [AutoMapFrom(typeof(Customer))]
  public class CustomerInfo
  {
      public string Name { get; set; }
  
      public string Phone { get; set; }
  
      public string Email { get; set; }
  
      public string Address { get; set; }
  }
  ```

#### 2.2 Application Service

- ###### **Application Service** 主要是由展現層呼叫，並以 **DTO** 作為 `傳入/傳出` 的參數

- ###### 命名方式: ***xxxAppService***

- ###### 詳情請參考 `Applciation Layer` > `Application Service`

- ```C#
  public class CustomerAppService : ApplicationService //也可以直接繼承 ~AppServiceBase
  {
      private readonly CustomerStore Store;
  
      public CustomerAppService(CustomerStore store)
      {
          Store = store;
      }
  
      public async Task CreatePerson(CreateCustomerInput input)
      {
          var customer = new Customer();
  
          ObjectMapper.Map(input, customer);
  
          await Store.Create(customer);
  
      }
  
      public async Task<List<CustomerInfo>> GetCustomerList()
      {
          return ObjectMapper.Map<List<CustomerInfo>>(await Store.GetCustomerList());
      }
  }
  ```

#### 2.3 資料結構

###### 依據各API切割資料結構

![image-20210211191120101](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210211191120101.png)

#### 2.4 流程

1. ###### 新增Application Service，建立API接口

2. ###### 針對各API的Request、Response參數建立對應DTO 物件



## 3.Notice

#### 3.1 Antiforgery

- ###### 原因 待補，修正後方可使用Post、Put等API接口

- 修正`.web` 專案 `startup.cs` 內　`ConfigureServices`

- ```C#
  services.AddControllersWithViews(options =>
  {
       //移除 options.Filters.Add(new AutoValidateAntiforgeryTokenAttribute()); 
      options.Filters.Add(new AbpAutoValidateAntiforgeryTokenAttribute()); //更換為此行
  }).AddNewtonsoftJson();
  ```

  



# 加入Swagger UI

## 1. 下載Swashbuckle.AspNetCore

## 2.  調整專案屬性

- ###### 調整Application Layer屬性中的輸出

- ###### 如果再IIS或docker中佈署時，API/首頁可以測通唯獨Swagger無法顯示，則請確認`Release`時有沒有產生XML檔案

![image-20210212140708230](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210212140708230.png)

## 3. 設定Startup.Cs

- ###### 載入Swagger插件至 `Startup.Cs`中

- ```C#
  public IServiceProvider ConfigureServices(IServiceCollection services)
  {
     //.......
      services.AddSwaggerGen(options =>
      {
          options.SwaggerDoc("v1", new OpenApiInfo() { Title = "ABP Framework API", Version = "v1" });
          options.DocInclusionPredicate((docName, description) => true);
  
          // Define the BearerAuth scheme that's in use
          options.AddSecurityDefinition("bearerAuth", new OpenApiSecurityScheme()
          {
              Description = "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\"",
              Name = "Authorization",
              In = ParameterLocation.Header,
              Type = SecuritySchemeType.ApiKey
          });
  
          var baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
  
          var CommentsFileName = @"ABPFramework.Application.xml";
          var CommentsFile = Path.Combine(baseDirectory, CommentsFileName);
          options.IncludeXmlComments(CommentsFile);
      });
  
     //.......
  }
  
  
  public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
  {
      app.UseAbp(); //Initializes ABP framework.
      app.UseSwagger();
      app.UseSwaggerUI(options =>
      {
          options.SwaggerEndpoint("/swagger/v1/swagger.json", "MyABPProject API V1");
          options.IndexStream = () => Assembly.GetExecutingAssembly()
              .GetManifestResourceStream("ABPFramework.Web.wwwroot.swagger.ui.index.html");
      }); // URL: /swagger
  }
  ```

## 4. 加入Swagger登入頁面

- ###### abp.swagger.js 處理API呼叫及動態建置畫面元件

  - ###### `openAuthDialog` 動態建置元件

  - `loginUserInternal` 處理使用者登入，包含畫面欄位驗證及Call API

  - ```js
     function loginUserInternal(tenantId, callback) {
                 
            var username = document.getElementById('userName').value;
            if (!username) {
                console.log("Missing UserName");
                return false;
            }
      
            var password = document.getElementById('password').value;
            if (!password) {
                console.log("Missing Password");
                return false;
            }
      
            var xhr = new XMLHttpRequest();
      
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    if (xhr.status === 200) {
                        var responseJSON = JSON.parse(xhr.responseText);
                        var result = responseJSON.result;
                        var expireDate = new Date(Date.now() + (result.expireInSeconds * 1000));
                        abp.auth.setToken(result.accessToken, expireDate);
                        callback();   
                    } else {
                        alert('Login failed !');
                    }
                }
            };
      
            xhr.open('POST', '/api/services/app/Auth/Login', true);
            xhr.setRequestHeader('Content-type', 'application/json');
            addAntiForgeryTokenToXhr(xhr);
            xhr.send(
                JSON.stringify(
                    { account: username, password: password, tenantCode: tenantCode}
                )
            );
        };
    ```

    

![image-20210212141351849](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210212141351849.png)

- 屬型切換為 `內嵌資源`、`永遠複製`

![image-20210212151942321](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210212151942321.png)

## 5. Notice

- ###### 其餘 Swagger UI相關功能，請直接參考Swagger UI 說明





# User Manager

- ###### 使用JWT驗證

- ###### 說明使用者認證、授權、權限管理...等相關功能與ABP原生功能的比較及如何使用、改寫

- ###### 所有預設功能接寫在`AuthorizationBase`資料夾中，並透過繼承的方式進行改寫及擴增使用



## 1. User

### 1.1 Entity

- ###### 定義使用者基本資料欄位

#### 1.1.1 `AbpUser`

- `AbpUser` 主要繼承自 `AbpUserBase`，裡面包含了多個預設屬性。由於目前多數專案大多由客戶方定義資料欄位數、及多個資料表的欄位關聯，因此在使用上會相對不方便

  ```C#
          //
          // 摘要:
          //     Permission definitions for this user.
          [ForeignKey("UserId")]
          public virtual ICollection<UserPermissionSetting> Permissions { get; set; }
          //
          // 摘要:
          //     Claims of this user.
          [ForeignKey("UserId")]
          public virtual ICollection<UserClaim> Claims { get; set; }
          //
          // 摘要:
          //     Roles of this user.
          [ForeignKey("UserId")]
          public virtual ICollection<UserRole> Roles { get; set; }
          //
          // 摘要:
          //     Login definitions for this user.
          [ForeignKey("UserId")]
          public virtual ICollection<UserLogin> Logins { get; set; }
         
          //
          // 摘要:
          //     Gets or sets the security stamp.
          [StringLength(128)]
          public virtual string SecurityStamp { get; set; }
          //
          // 摘要:
          //     Is the Abp.Authorization.Users.AbpUserBase.PhoneNumber confirmed.
          public virtual bool IsPhoneNumberConfirmed { get; set; }
          //
          // 摘要:
          //     Gets or sets the phone number.
          [StringLength(32)]
          public virtual string PhoneNumber { get; set; }
          //
          // 摘要:
          //     Gets or sets the lockout enabled.
          public virtual bool IsLockoutEnabled { get; set; }
          //
          // 摘要:
          //     Gets or sets the access failed count.
          public virtual int AccessFailedCount { get; set; }
          //
          // 摘要:
          //     Lockout end date.
          public virtual DateTime? LockoutEndDateUtc { get; set; }
          //
          // 摘要:
          //     Reset code for password. It's not valid if it's null. It's for one usage and
          //     must be set to null after reset.
          [StringLength(328)]
          public virtual string PasswordResetCode { get; set; }
          //
          // 摘要:
          //     Email address of the user. Email address must be unique for it's tenant.
          [Required]
          [StringLength(256)]
          public virtual string EmailAddress { get; set; }
          //
          // 摘要:
          //     Password of the user.
          [Required]
          [StringLength(128)]
          public virtual string Password { get; set; }
          //
          // 摘要:
          //     Return full name (Name Surname )
          [NotMapped]
          public virtual string FullName { get; }
          //
          // 摘要:
          //     Surname of the user.
          [Required]
          [StringLength(64)]
          public virtual string Surname { get; set; }
          //
          // 摘要:
          //     Name of the user.
          [Required]
          [StringLength(64)]
          public virtual string Name { get; set; }
          //
          // 摘要:
          //     Is the Abp.Authorization.Users.AbpUserBase.EmailAddress confirmed.
          public virtual bool IsEmailConfirmed { get; set; }
          //
          // 摘要:
          //     Tenant Id of this user.
          public virtual int? TenantId { get; set; }
          //
          // 摘要:
          //     User name. User name must be unique for it's tenant.
          [Required]
          [StringLength(256)]
          public virtual string UserName { get; set; }
          //
          // 摘要:
          //     Authorization source name. It's set to external authentication source name if
          //     created by an external source. Default: null.
          [StringLength(64)]
          public virtual string AuthenticationSource { get; set; }
          //
          // 摘要:
          //     Confirmation code for email.
          [StringLength(328)]
          public virtual string EmailConfirmationCode { get; set; }
          //
          // 摘要:
          //     Is this user active? If as user is not active, he/she can not use the application.
          public virtual bool IsActive { get; set; }
  ```

#### 1.1.2  自訂義 `User`

- `Authorization` > `User`定義出使用者在進行認證所需的基本欄位如，**帳號**、**密碼**、**名稱**、**Email**。後續再根據各專案進行使用者欄位擴增，將能大幅提升開法上的速度

  ```C#
  public class UserBase : AuditedEntity
  {
      /// <summary>
      /// 使用者帳號
      /// </summary>
      public virtual string Account { get; set; }
  
      /// <summary>
      /// 密码
      /// </summary>
      public virtual string Password { get; set; }
  
      /// <summary>
      /// 姓名
      /// </summary>
      public virtual string Name { get; set; }
      
      /// <summary>
      /// Mail
      /// </summary>
      public virtual string Email { get; set; }
  }
  ```

  


### 1.2 UserStore

#### 1.2.1 AbpUserStore

- ###### 繼承多個 `.NetCore Identity  `原生`Store`

```C#
public class AbpUserStore<TRole, TUser> : IUserLoginStore<TUser>, IUserStore<TUser>,  IUserRoleStore<TUser>, IUserClaimStore<TUser>,.....
```

- ###### 引用多個 `ABP` Repository

  ```C#
  public AbpUserStore(IUnitOfWorkManager unitOfWorkManager, IRepository<TUser, long> userRepository, IRepository<TRole> roleRepository, IRepository<UserRole, long> userRoleRepository, IRepository<UserLogin, long> userLoginRepository, IRepository<UserClaim, long> userClaimRepository, IRepository<UserPermissionSetting, long> userPermissionSettingRepository, IRepository<UserOrganizationUnit, long> userOrganizationUnitRepository, IRepository<OrganizationUnitRole, long> organizationUnitRoleRepository);
  ```

#### 1.2.2 自訂義 `UserStore`

- ###### 考量到目前專案的性質，多數.NetCore Identity 原生Store內部的函式可能無實際作用。因此，在基底類別中只會繼承幾個常用的函示庫，以減少無用程式碼。

- ###### 後續針對使用者資料表的相關CRUD處理，可直接調整此函示庫



### 1.3 UserManager

- ###### 定義與使用者相關的業務邏輯

#### 1.3.1 AbpUserManager

- ###### 綁定`AbpUser`、`AbpRole`、`AbpUserStore` 等基底類別，導致在使用上延展性不高

- ###### 引用多個ABP定義函式庫

- ```C#
   public AbpUserManager(AbpRoleManager<TRole, TUser> roleManager, AbpUserStore<TRole, TUser> userStore, IOptions<IdentityOptions> optionsAccessor, IPasswordHasher<TUser> passwordHasher, IEnumerable<IUserValidator<TUser>> userValidators, IEnumerable<IPasswordValidator<TUser>> passwordValidators, ILookupNormalizer keyNormalizer, IdentityErrorDescriber errors, IServiceProvider services, ILogger<UserManager<TUser>> logger, IPermissionManager permissionManager, IUnitOfWorkManager unitOfWorkManager, ICacheManager cacheManager, IRepository<OrganizationUnit, long> organizationUnitRepository, IRepository<UserOrganizationUnit, long> userOrganizationUnitRepository, IOrganizationUnitSettings organizationUnitSettings, ISettingManager settingManager);
    
  ```

#### 1.3.2 自訂義 UserManagerBase

- ###### 定義使用者管理相關的基本函式，並提供覆寫供各專案依據實務狀況進行變更

- ###### 後續若有需要則在各專案中的`Authorization` > `UserManager`自行調整即可



### 1.4 ClaimsPrincipalFactory

- ###### 定義回傳的Token內，`Claims`所夾帶的使用者訊息

- ###### 繼承至`.NetCore Identity` 原生 `UserClaimsPrincipalFactory`

```C#
public override async Task<ClaimsPrincipal> CreateAsync(TUser user)
{
    var claims = new List<Claim>() {
        new Claim(ClaimTypes.Name, user.Name),
        new Claim(ClaimTypes.Email, user.Email),
        new Claim(ClaimTypes.NameIdentifier, user.Id.ToString())
        };

    var id = new ClaimsIdentity(claims, "Identity.Application");

    return new ClaimsPrincipal(id);
}
```



### 1.5 LoginManager

- ###### 定義使用者登入時，從 *登入驗證* 到 *發放Token* 的一系列流程及驗證邏輯

- ###### 使用者資料庫資料存取統一放在UserManager

### 1.6 IdentityRegistrar

- 位於 `ABPFramework.Web `> `Startup` > `Auth`
- 透過`DI` 的方式在建置階段預先註冊Auth相關函式庫

### 1.7  TokenManager

- ###### 透過登入者的Token取得Claims內容，並回傳對應使用者資料

### 1.8 UserAuthorizationHelper

- ###### 用來進行使用者Token驗證的基底類別，包含Token的驗證及Permission的驗證

- ###### 會在 **Application Service**的 `AbpAuthorize` 時呼叫驗證

- ###### API的權限驗證也在這邊進行

- ###### `IEnumerable<IAbpAuthorizeAttribute>` 會根據 **Application Service** 中 `AbpAuthorize` 所傳入的參數內容進行權限驗證

  - ![image-20201221143112437](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20201221143112437.png)

    

- ###### 下面附上的是ABP原生地函式內容

  ```C#
  namespace Abp.Authorization
  {
      public class AuthorizationHelper : IAuthorizationHelper, ITransientDependency
      {
          public IAbpSession AbpSession { get; set; }
          public IPermissionChecker PermissionChecker { get; set; }
          public ILocalizationManager LocalizationManager { get; set; }
  
          private readonly IFeatureChecker _featureChecker;
          private readonly IAuthorizationConfiguration _authConfiguration;
  
          public AuthorizationHelper(IFeatureChecker featureChecker, IAuthorizationConfiguration authConfiguration)
          {
              _featureChecker = featureChecker;
              _authConfiguration = authConfiguration;
              AbpSession = NullAbpSession.Instance;
              PermissionChecker = NullPermissionChecker.Instance;
              LocalizationManager = NullLocalizationManager.Instance;
          }
  
          public virtual async Task AuthorizeAsync(IEnumerable<IAbpAuthorizeAttribute> authorizeAttributes)
          {
              if (!_authConfiguration.IsEnabled)
              {
                  return;
              }
  
              if (!AbpSession.UserId.HasValue)
              {
                  throw new AbpAuthorizationException(
                      LocalizationManager.GetString(AbpConsts.LocalizationSourceName, "CurrentUserDidNotLoginToTheApplication")
                      );
              }
  
              foreach (var authorizeAttribute in authorizeAttributes)
              {
                  await PermissionChecker.AuthorizeAsync(authorizeAttribute.RequireAllPermissions, authorizeAttribute.Permissions);
              }
          }
  
          public virtual void Authorize(IEnumerable<IAbpAuthorizeAttribute> authorizeAttributes)
          {
              if (!_authConfiguration.IsEnabled)
              {
                  return;
              }
  
              if (!AbpSession.UserId.HasValue)
              {
                  throw new AbpAuthorizationException(
                      LocalizationManager.GetString(AbpConsts.LocalizationSourceName, "CurrentUserDidNotLoginToTheApplication")
                      );
              }
  
              foreach (var authorizeAttribute in authorizeAttributes)
              {
                  PermissionChecker.Authorize(authorizeAttribute.RequireAllPermissions, authorizeAttribute.Permissions);
              }
          }
  
          public virtual async Task AuthorizeAsync(MethodInfo methodInfo, Type type)
          {
              await CheckFeaturesAsync(methodInfo, type);
              await CheckPermissionsAsync(methodInfo, type);
          }
  
          public virtual void Authorize(MethodInfo methodInfo, Type type)
          {
              CheckFeatures(methodInfo, type);
              CheckPermissions(methodInfo, type);
          }
  
          protected virtual async Task CheckFeaturesAsync(MethodInfo methodInfo, Type type)
          {
              var featureAttributes = ReflectionHelper.GetAttributesOfMemberAndType<RequiresFeatureAttribute>(methodInfo, type);
  
              if (featureAttributes.Count <= 0)
              {
                  return;
              }
  
              foreach (var featureAttribute in featureAttributes)
              {
                  await _featureChecker.CheckEnabledAsync(featureAttribute.RequiresAll, featureAttribute.Features);
              }
          }
  
          protected virtual void CheckFeatures(MethodInfo methodInfo, Type type)
          {
              var featureAttributes = ReflectionHelper.GetAttributesOfMemberAndType<RequiresFeatureAttribute>(methodInfo, type);
  
              if (featureAttributes.Count <= 0)
              {
                  return;
              }
  
              foreach (var featureAttribute in featureAttributes)
              {
                  _featureChecker.CheckEnabled(featureAttribute.RequiresAll, featureAttribute.Features);
              }
          }
  
          protected virtual async Task CheckPermissionsAsync(MethodInfo methodInfo, Type type)
          {
              if (!_authConfiguration.IsEnabled)
              {
                  return;
              }
  
              if (AllowAnonymous(methodInfo, type))
              {
                  return;
              }
  
              if (ReflectionHelper.IsPropertyGetterSetterMethod(methodInfo, type))
              {
                  return;
              }
  
              if (!methodInfo.IsPublic && !methodInfo.GetCustomAttributes().OfType<IAbpAuthorizeAttribute>().Any())
              {
                  return;
              }
  
              var authorizeAttributes =
                  ReflectionHelper
                      .GetAttributesOfMemberAndType(methodInfo, type)
                      .OfType<IAbpAuthorizeAttribute>()
                      .ToArray();
  
              if (!authorizeAttributes.Any())
              {
                  return;
              }
  
              await AuthorizeAsync(authorizeAttributes);
          }
  
          protected virtual void CheckPermissions(MethodInfo methodInfo, Type type)
          {
              if (!_authConfiguration.IsEnabled)
              {
                  return;
              }
  
              if (AllowAnonymous(methodInfo, type))
              {
                  return;
              }
  
              if (ReflectionHelper.IsPropertyGetterSetterMethod(methodInfo, type))
              {
                  return;
              }
  
              if (!methodInfo.IsPublic && !methodInfo.GetCustomAttributes().OfType<IAbpAuthorizeAttribute>().Any())
              {
                  return;
              }
  
              var authorizeAttributes =
                  ReflectionHelper
                      .GetAttributesOfMemberAndType(methodInfo, type)
                      .OfType<IAbpAuthorizeAttribute>()
                      .ToArray();
  
              if (!authorizeAttributes.Any())
              {
                  return;
              }
  
              Authorize(authorizeAttributes);
          }
  
          private static bool AllowAnonymous(MemberInfo memberInfo, Type type)
          {
              return ReflectionHelper
                  .GetAttributesOfMemberAndType(memberInfo, type)
                  .OfType<IAbpAllowAnonymousAttribute>()
                  .Any();
          }
      }
  }
  ```

  

### 1.9 Auth引用流程

1. ######  將`ABPFramework.Core`  > `Authorization` 資料夾完整帶入

2. ######  在 `~.Web `> `Startup` > `Auth` 並建立 **IdentityRegistrar.cs** 及 **AuthConfigurer.cs** 

3. ###### 在 `~.Web `> `Startup` > `Startup.cs` 加入以下內容

   ```C#
   public IServiceProvider ConfigureServices(IServiceCollection services)
   {
       // ~~~~
       IdentityRegistrar.Register(services);
       AuthConfigurer.Configure(services, _appConfiguration);
   
   }
   
   public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
   {
   
   	/-----
   
       app.UseAuthentication();
   
       
   }
   ```

4. ###### `~.Application` > `Authorization`帶入。裡面包含驗證及取得登入者身分的基本API ，或自行建立Login API

5. 使用`AbpAuthorize` 將API進行驗證保護，權限部分請參考後面內容



## 2. 權限

### 2.1 預設結構

1. ######  User : 定義使用者基本資料

2. ######  Role:  定義角色基本資料

3. ######  RoleUser : 定義使用者與角色間的對照

4. ######  Permission: 定義權限基本資料

5. ######  RolePermission: 定義角色與權限對應

6. ###### 預設流程

   1. ###### 使用者登入後透過`RoleUser`取得對應角色清單

   2. ###### 在回傳的Token內部會包含 `Role` 的 ID資料

   3. ###### 在驗證權限時，透過使用者 Token內的 RoleId至`RolePermission` 取得對應的 `PermissionID`清單

   4. ###### 透過 `PermissionID` 清單取得對應權限資料

![image-20210214154320741](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210214154320741.png)

### 2.2 使用說明

- ###### 權限控管不一定要使用到Permission階層，有些專案是根據角色控管API使用權限。

- 因此權限控管方式也提供`Role` 及 `Permission`兩種

#### 2.2.1 使用 Role 管制API

1. ###### 定義好Role資料表內角色清單，`permission`、`RolePermission`可以不用處理

2. 調整 `Authorization` > `Permissions` > `PermissionChecker` > GetUserPermissions函式

   - 將 `UserPermissions`變數改對應角色代碼即可

   - ```C#
     private async Task GetUserPermissions()
     {
         var roleIds = TokenManager.ExtractClaims(ClaimTypes.Role).ToList();
     
         UserPermissions = await RoleManager.GetRoles(roleIds);
     }
     ```

3.  API的管控改以對應的角色清單

   ![image-20210214155958140](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210214155958140.png)

#### 2.2.2 使用 Permission管制API

1. 專案框架預設使用`Permission` 管控API，因此驗證方式可直接使用

2. ###### 如果Permission、Role的結構有所改變，可調整 `Authorization` > `Permissions` > `GetUserPermissions`  內部 UserPermissions的給值方式即可

### 2.3 相關函式

#### 2.3.1 PermissionChecker

- 驗證使用者是否有權限進入被管制的API

- API管制方式如下圖

  - 管制整個Service

    ```C#
    [AbpAuthorize(PermissionCodes.PageUsers)]
    public class CustomerAppService : ApplicationService
    {
    
        /// <summary>
        ///  新增客戶
        /// </summary>
        public async Task CreatePerson(CreateCustomerInput input)
        {
        }
    }
    ```

  - 管制個別API

    ```
    public class CustomerAppService : ApplicationService
    {
        [AbpAuthorize(PermissionCodes.CreateUser)]
        public async Task CreatePerson(CreateCustomerInput input)
        {
        }
        
        [AbpAuthorize(PermissionCodes.EditUser)]
        public async Task UpdatePerson(CreateCustomerInput input)
        {
        }
    }
    ```

  - 多權限管制

    ```C#
    
    [AbpAuthorize(PermissionCodes.CreateUser,PermissionCodes.EditUser)]
    public class CustomerAppService : ApplicationService
    {
        public async Task CreatePerson(CreateCustomerInput input)
        {
        }
        
        public async Task UpdatePerson(CreateCustomerInput input)
        {
        }
    }
    ```

#### 2.3.2  SessionManager

- ###### ABP內部有些過濾條件會依據`IAbpSession` 內的值做篩選。如使用MultiTenant時，資料表會自動根據Session中的`TenantId`做判斷。

- ###### 在`~CoreModule`已經透過DI的方式將SessionManager取代IAbpSession。因此，原先ABP過濾的屬性欄位皆(如，tenantId、userId...)可直接透過Manager變更取值方式

- ###### `IAbpSession`內的資料主要是從Token內部的Claims取得。`Session`除了繼承原有的屬性外，也可以針對各專案新增User Claims裡面新增的屬性



## 3. 多組織架構(Multi-Tenancy)

- ###### ABP 內建提供多組織架構，資料表內 加入`IMayHaveTenant` 、`IMustHaveTenant` 就能在查找資料時自動過濾組織資料。

  - ###### 在 `IAbpSession`中有一個 `TenantId`的值，預設取得Claims中的`AbpClaimTypes.TenantId`值。

  - ###### 如果開啟多組織架構時資料表會自動根據TenantId去做資料篩選。(例如，登入者Session內TenantId取得為`組織編號3`，則有使用多組織註記的資料表會自動篩選編號為3的內容出來)

  - ###### 多組織標記

    - ######  IMustHaveTenant: 加入此註記的資料表會自動產生`TenantId`欄位，且該欄位為必填。並且在新增資料時會自動根據登入者的TenantId塞入欄位資料。

    - ###### IMayHaveTenant: 加入此註記的資料表會自動產生`TenantId`欄位，該欄位為非必填。在進行資料新增時，必須主動給予TenantId欄位數值。

    - ###### 兩則標記共通處在於查詢資料時，只要有開啟多組織標記則資料表會自動根據登入者TenantId篩選資料

    - ```C#
      Configuration.MultiTenancy.IsEnabled = true; //在Module內加入開啟多組織架構
      ```

    - ###### 沒有使用多組織標記的資料表不在此限中

- ###### 由於目前專案屬性，因此框架預設不啟用多組織架構。下面簡要說明加入多組織架構的流程

  1. ######  在 `~CoreModule` > `PreInitialize`內加入

     ```C#
     onfiguration.MultiTenancy.IsEnabled = true; //啟動多組織架構
     ```

  2. ######  實作組織架構的相關資料表、函式及使用者關聯。並在登入時根據登入者身分加入組織編號資料進入Claims中

     1. 登入時取得登入者組織編號

     2. 於 `Authorization` > `ClaimsPrincipalFactory` 內加入`tenantId`

        ```C#
        principal.Identities.First().AddClaim(new Claim(AbpClaimTypes.TenantId, user?.TenantId.ToString()));
        ```

  3. ######  `Authorization`  >  `SessionManager` 預設取得 Claims內 `AbpClaimTypes.TenantId`資料作為登入者的 TenantId，若有需要變更請自行改寫

  4. ###### 資料表內 加入`IMayHaveTenant` 、`IMustHaveTenant` ，系統即會自動根據TenantId欄位進行資料過濾

- ## Notice

  - ###### ABP預設有PowerUser的權限，當Session回傳的`TenantId`為NULL時，該登入者即視為最高權限使用者。該使用者可以查看所有的資料表，而不會根據TenantId篩選。



# IIS 部署

1. 確認資料夾權限

2.  安裝環境

   1. dotnet-hosting https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/?view=aspnetcore-3.1#install-the-net-core-hosting-bundle 

   [SDK、RunTime]: https://dotnet.microsoft.com/download



## IIS環境設定

1. ###### .NetCore 裡面可以依據IIS的環境設定，自動取得不同版本的環境設定檔 (appsettings.XXX.json )

2. ######  因此，再設定IIS時，需要先定義這次執行的環境值

   1. 關閉準備設定的IIS站台

   2. ######  開啟IIS站台並點選設定編輯器

      ![image-20210712141520635](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210712141520635.png)

   3. ###### 選擇“system.webServer/aspNetCore”

      ![image-20210712141732394](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210712141732394.png)

   4. ###### 再找到“environmentVariable”项，點擊編輯項目

      ![image-20210712141918893](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210712141918893.png)

   5. ###### 找到或新增 `ASPNETCORE_ENVIRONMENT` 環境變數，並給定變數值 (Production)。

      - ###### 這邊的變數值根據你想要讀取的 `appsettings.XXX.json ` 填入 XXX

      ![image-20210712142130492](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210712142130492.png)

   6. 完成後請點選套用並重啟IIS站台，確認該數值有正確存入

      ![image-20210712142408836](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210712142408836.png)



## PUT And Delete 權限

- **HTTP 错误 405.0 - Method Not Allowed** - 出現此錯誤時請做以下調整
- ![image-20210312153639993](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20210312153639993.png)

## 確保排程持續啟動

- 由於IIS會自動回收期限內沒有使用的**application pool**。因此長時間的排程(Quatz)會被自動關閉。

  ![image-20200629162856867](https://raw.githubusercontent.com/Sean2416/Pic/master/img/image-20200629162856867.png)

  

- 因此，必須調整IIS的設定

  1. ###### **Install the Application Initialization Module**

     ![Install IIS application initialization module](https://i0.wp.com/www.taithienbo.com/wp-content/uploads/screenshots/IIS_Application_Initialization/Screen-Shot-2018-10-06-at-3.07.30-PM-1.png?ssl=1)

     

  2. **設定應用程式集區**

     - Idle time-out(閒置愈時): 0代表永遠不會處於閒置狀態，因此不會被回收

     - start mode to “Always Running” tells IIS to start a worker process for your application right away, without waiting for the initial request.

       

     ![img](https://i0.wp.com/www.taithienbo.com/wp-content/uploads/2018/10/IIS_AppPool_Settings_AlwaysRunning.png?ssl=1)

     

  3. **設定IIS網站**

     ![Install IIS application initialization module](https://i2.wp.com/www.taithienbo.com/wp-content/uploads/screenshots/IIS_Application_Initialization/Screen-Shot-2018-10-06-at-4.22.39-PM-2.png?ssl=1)

