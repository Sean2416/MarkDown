# SQL

## Index(索引)

- ##### 使用的資料結構(B+ tree)

- ##### 加速查詢時間、增加寫入時間

  - 每個`Index`都會建立一顆`b+ tree`
  - 每次新增、更新資料時都會異動到有使用的`b+ tree`

- ##### 通常會加上索引的欄位

  - ###### 主鍵 Primary Key（通常是預設）

  - ###### 外部鍵 Foreign Key

  - ###### 常被放在查詢子句中（`ORDER`, `WHERE`, `GROUP`）的欄位

### Clustered Index(叢集索引)

- ##### 每個資料表只能有一個`叢集索引`。資料表「實體資料列」的順序會依據叢集索引的值做排序

  - ###### `Cluster index`好比書籍頁碼目錄。每本書只能有一個目錄

- ##### 建立`Clustered Index`欄位有幾個重點

  - ###### 常用於查詢欄位

  - ###### 可識別度高(唯一性較高)

  - ###### 盡量少被Update

  - ###### 連續性佳

- ##### SQL Server  資料表的**主索鍵**（PK），預設為「叢集索引」且是唯一的（Unique）

- ##### 查詢資料速度: 叢集索引 > 非叢集索引

### NonClustered Index(非叢集索引)

- ##### 叢集索引的排列順序就是實際上資料的排列順序，而非叢集索引的排列順序不會/無法影響到實際資料的排列順序

- ##### 每個資料表能有許多`非叢集索引`，像每本書可以有很多種附錄

  - ###### 例如依照字母排序

  - ###### 依照附錄A

- ##### 非叢集索引上所有分葉節點存放指標，如果資料表已存在`叢集索引`(`KeyID`)，那麼該指標將會指`叢集索引`，如不存在將指向資料真實存放位置(`RID`)

  - ###### 如果`非叢集索引`沒有包含所有要查詢欄位

    - 有`Clustered Index`，會執行`Key Lookup`。假如搜尋`非叢集索`沒有辦法滿足所有查詢需要資料就會去`Key Lookup`(by Clustered key)回找`Clustered Index`取出相對應的資料.
    - 沒有`Clustered Index`，會執行`RID Lookup`。`lookup`會消耗`Disk I/O`，所以消耗成本相對會比較大.

#### Covering Index

- ##### 在`非叢集索引`把`Column`加入`INCLUDE`區域後此`NONCLUSTERED INDEX`會把此欄位資料加入至子頁層.之後如果要查找資料時就不用在`Lookup`回去

  - ```SQL
    CREATE NONCLUSTERED INDEX IX_T_Id_Convering on dbo.T(
    	id
    ) INCLUDE (
    	UserId,
    	UserGroup
    )
    ```

  - ![img](https://i.imgur.com/8TvUoRY.png)

- ##### 如果每次只需要`SELECT`少部分欄位且範圍較大又須排序，`Covering Index`執行效率會比`CLUSTERED INDEX`來的快.

- ##### 缺點

  1. ###### 假如在此次update有包含index include columns時,此次修改也會對於Index子頁層進行資料更新，這會增加I/O和Transaction log.

  2. ###### 因為會把include columns增加在NonClustered Index子頁層這會增加硬碟儲存Index的額外空間.



## 正規化

- ##### 為了降低資料的「重覆性」 與避免「更新異常」的情況發生

  - ###### 減少重複的資料散落在不同表中，導致更新時遺漏產生的資料異常

  - ###### 是讓資料庫中重複的欄位資料減到最 少，並且能快速的找到資料，以提高關聯性資料庫的效能。

- ##### 原先關聯 (表格 )的所有資訊，在「分解」之後，仍能由數個新關 聯 (表格 )中經過「合併」得到相同的資訊。

- ##### 資料表正規化的過程 (1NF 到 BCNF) 中, 每一個階段都是以欄位的 「相依性」, 做為分割資料表的依據之一。

  - ![img](https://image3.slideserve.com/6018104/slide30-l.jpg)

  

### 第一正規化(1NF)

- ![img](https://i0.wp.com/blog.build-school.com/wp-content/uploads/2022/07/image.png?resize=681%2C352&ssl=1)

- ![img](https://i0.wp.com/blog.build-school.com/wp-content/uploads/2022/07/image-2.png?resize=723%2C120&ssl=1)

- #### 把資料表攤開變成單一值，並加入唯一值

  - ###### 定義主鍵值（primary key）以及單一值

- ##### 每一列資料的欄位值都只能是單一值

  - ###### 每一個Column都只能有一個值(如，範例一個學生的row data 裡面儲存了多項課程)

  - ###### 單一個欄位內有超過1個以上的值。欄位長度無法確定（可能很多，也可能很少），必須預留空間，造成儲存空間的浪費。

- ##### 沒有任何兩筆以上的資料完全重複。

- ##### 資料表中需有主鍵（唯一值），其他所有欄位都相依於主鍵。

- ##### 同一張資料表內，不建議用多個欄位表達同一個事情（如下圖，不喜歡的食物）

  - ![img](https://i0.wp.com/blog.build-school.com/wp-content/uploads/2022/07/image-4.png?resize=553%2C180&ssl=1)

  - ###### 作法

    - 確認是否有重複表達的欄位。
    - 將欄位內重複的資料分別存為不同的Data Row資料。

![img](https://i0.wp.com/blog.build-school.com/wp-content/uploads/2022/07/image-6.png?resize=723%2C297&ssl=1)



### 第二正規化（2NF）

- ##### 定義

  - ###### 符合1NF。

  - ###### 去除相依性，使用外部索引鍵，讓這些資料表產生關聯，而不是一張 table 塞入所有資訊

  - ###### 消除「部分功能相依」，每一個非鍵欄位必須完全相依主鍵（學號=>學生，課程=>學分…），通常「主鍵有多個欄位」組成時會發生「部分功能相依」。

    - ###### 每一個學號都只會也只能對應到一個學生

    - ###### 課程代碼對應到課程名稱、學分、必選修、老師編號等

- ##### 避免同一個主鑑對應到的內容不同。ex.相同課程代碼對應不同課程名稱

- 將學生資料獨立出來，並用學號做關聯。 課程資料用課程代碼做關聯，如此可以確保每一個key對應的內容都是一致的。

  - ![img](https://i0.wp.com/blog.build-school.com/wp-content/uploads/2022/07/image-8.png?resize=723%2C723&ssl=1)

  - ##### 發現「重複的資料」，因為需符合1NF，所以將重複的資料去除

    - ![img](https://i0.wp.com/blog.build-school.com/wp-content/uploads/2022/07/image-9.png?resize=723%2C587&ssl=1)

### 第三正規化（3NF）

- #### 定義

  - ###### 符合2NF。

  - ###### 各欄位之間沒有存在「遞移相依」的關係，也就是與「主鍵」無關的相依性。

    - ###### X->Y,Y->Z 所以X->Z

    - ###### 課程資料表中，老師編號相依於課程代碼、老師姓名又相依老師編號。所以老師姓名與課程編號(key)沒有直接相依姓

  - ###### 刪除不依賴索引鍵的欄位，例如說：訂單數量 `count` 與單價 `unit_price` 已經存在表單，又多了每一筆訂單的 amount，就是不必要的

- ##### 作法

  - ###### 檢查是否存在「遞移相依」的欄位。

  - ###### 將「遞移相依」的欄位分割出去，另外組成新的資料表。

- 分割欄位

  - ![img](https://i0.wp.com/blog.build-school.com/wp-content/uploads/2022/07/image-11.png?resize=723%2C169&ssl=1)

### Boyee-Codd正規化（BCNF）

- ##### 視情況使用，實務上大多都只會做到3NF。

- ##### 3NF的改良式(必須滿足3NF)。

- ##### 主鍵中的各欄位（單獨看）不可以相依於其他非主鍵的欄位。

- ##### 成績資料表

  - ###### 3NF

  - ###### 主鍵由兩個欄位組成，但：

    - ###### 成績相依於「學號」及「課程代碼」欄位

    - ###### 成績未相依於「學號」（必須要有課程代碼才知道是哪堂課的分數）

    - ###### 成績未相依於「課程代碼」（必須要有學號才知道是誰的分數）

  - ###### 符合BCNF



## 資料庫反正規化

- ##### [資料庫正規化](https://www.explainthis.io/zh-hant/swe/database-normalization)是透過分表的的方式去做到**降低資料的重複性、去除相依性**等，但他的缺點顯而易見，**表跟表之間的耦合性會很高、而且利用 `JOIN` 的方式查詢會導致速度變慢、拆成多張表的儲存成本也較高**。

- ##### 反正規化是一種將資料庫中的資料再次加工，將資料從正規化狀態轉換為非正規化狀態的過程。

  - ###### 反正規化不等於非正規化，反正規化是先遵守正規化的所有規則，再進行局部調整，故意打破一些正規化規則；而後者非正規化是全然不顧規則。

  - ###### 通過增加冗餘數據或對數據進行分組，**犧牲一部分的寫入性能，換取更高的讀取性能**。

  - ###### 簡單來說，反正規化就是要把**某些數據在不同地方多放幾份，加快數據檢索速度**。

- ##### Pre-joining Tables

  - ##### 預先將兩張表或多張表 `JOIN` 起來，而會這樣做通常是因為：

    - ###### 在查找時，兩張表或多張表常常需要一起查找

    - ###### `JOIN` 時是需要耗費大量資源

  - ##### 舉例: Shop的物流或退費都以order_merchant_id做關聯，當我們以訂單的角度去找時需要透過join的方式串回訂單增加查詢效能

    - ###### 解法: 將order_id、order_no加入物流資料內(不符合3NF，因為物流跟訂單沒有直接相依，而是相依於銷售單)

- ##### 優點

  1. ###### 查詢效能提升：通過將資訊放在一起，可能增加冗餘性。單因為 `JOIN` 的數量減少，這會提高查詢效能。

  2. ###### 方便管理：由於粒度高，正規化資料庫很難管理；相反的，反正規化可以提供易於使用的資料，而不是 `JOIN` 完才能知道其資料的完整性。

  3. ###### 提升報告化過程：分析資料需要迅速進行大量計算。反正規化資料庫生成報告是提供分析資訊的理想解決方案。

- ##### 缺點

  1. ###### 提升複雜性：在插入、更新資料時增加複雜性以及成本。

  2. ###### 不一致性：因為數據難以更新，所以可能會有數據不一致的問題。

  3. ###### 增加存儲負擔：由於增加了資料的冗余，因此需要更大的儲存空間。

- 